# kaisai-password
凯撒密码
一、基础知识介绍
由来：凯撒密码（caeser）是罗马扩张时期朱利斯•凯撒（Julius Caesar）创造的，用于加密通过信使传递的作战命令。它将字母表中的字母移动一定位置而实现加密。
原理：在密码学中，恺撒密码（或称恺撒加密、恺撒变换、变换加密）是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。
假如有这样一条指令：
　　明文（小写）：ji xiao jing
　　用恺撒密码加密后就成为：
　　密文（大写）：ML ALDR MLQJ
　　如果这份指令被敌方截获，也将不会泄密，因为字面上看不出任何意义。
　　这种加密方法还可以依据移位的不同产生新的变化，如将每个字母左19位，就产生这样一个明密对照表：
　　明文:a b c d e f g h i j k l m n o pq r s t u v w x y z
　　密文:T U V W X Y Z A B C D E F G H I J K L M N O P Q R S
　　在这个加密表下，明文与密文的对照关系就变成：
　　明文：b a i d u
　　密文：UTB WN
　　很明显，这种密码的密度是很低的，只需简单地统计字频就可以破译。
二、环境介绍
1.语言：C语言
2.编译环境：Visual Studio 2015
三、思路以及算法分析
编程思路及算法分析：
首先获取要加密的内容以及密钥，凯撒密码的密钥即字符移动的位数。由于凯撒密码的移位是针对字符的，因此需要将待加密的内容中每个字符取出，然后针对每个字符分别加以移位。
1.选择加密或解密
用switch语句进行选择加密或解密，输入1时执行case 1进行加密，输入2执行case 2进行解密，输入3执行case 3退出，若输入其它数字则执行default输出错误提示。
2.读取字符串和密钥
输入字符串用到get(a) ,字符串中可以包括任意字符；
输入密钥用到scanf("%d",&k) 密钥是整数所以用%d。
3.依次取出字符串中的字符
用for(i=0;i<strlen(a);i++)依次取出输入的字符串中的全部字符，然后进行下一步的移位。
4.对每个字符进行移位
加密算法：a[i]='a'+(a[i]-'a'+(k%26)+26)%26，a[i]=('A'+(a[i]-'A'+(k%26)+26)%26)
解密算法：a[i]='a'+(a[i]-'a'-(k%26)+26)%26，a[i]=('A'+(a[i]-'A'-(k%26)+26)%26)
分析：此算法中密钥k可以是任意的整数，由于字母表中共26个字符，因此移位前先将移动的位数(key)和26取模。由于C中字符和整型可自动转换，因此将字符加上一个正整数即代表在字母表中右移多少位。如果移动的位数是负值，则代表在字母表中左移多少位。此算法中小写字母加密解密后为小写字母，大写字母加密解密后为大写字母，其他字符（包括空格）不变。
四、源程序代码
#include<stdio.h>  
#include<string.h> 
#define m 20
void main()
{
	int c,i,k;
	char a[m];
	printf("1.加密 2.解密 3.退出\n请选择：");      //选择菜单
	scanf("%d",&c);                             //选择加密或解密
	fflush(stdin);                            //为下面get()语句清空缓存
	switch(c)                                   //switch语句执行选择
	{
	case 1:                                         //选择加密后进入并执行此语句
        printf("请输入明文："); 
         gets(a);                                 //输入要进行加密的明文
		printf("请输入密钥：");
		 scanf("%d",&k);                        //输入密钥
         for(i=0;i<strlen(a);i++)                //依次取出明文字符进行加密
		 {
			 if('a'<=a[i] && a[i]<='z')
			 {
               a[i]=('a'+(a[i]-'a'+(k%26)+26)%26);     //实现明文字符的移动，实现加密
			 }
			 else if('A'<=a[i] && a[i]<='Z')
			 {
				 a[i]=('A'+(a[i]-'A'+(k%26)+26)%26);
			 }
		 }
		 printf("密文为：");
		 puts(a);                                 //输出加密后的密文
	break;
	case 2:                                         //选择解密后进入并执行此语句
        printf("请输入密文：");              
         gets(a);                                  //输入要解密的密文
		printf("请输入密钥：");
		 scanf("%d",&k);                             //输入密钥

         for(i=0;i<strlen(a);i++)                  //依次取出密文中的所有字符
		 {
			 if('a'<=a[i] && a[i]<='z')            //判断条件为小写字母
			 {
               a[i]='a'+(a[i]-'a'-(k%26)+26)%26;    //实现密文字符的移动，实现解密
			 }
			 else if('A'<=a[i] && a[i]<='Z')         //判断条件为大写字母
			 {
				 a[i]=('A'+(a[i]-'A'-(k%26)+26)%26);  //实现密文字符的移动，实现解密 
			 }
		 }
		 printf("明文为：");       
		 puts(a);                                  //输出解密后的明文
	break;
	case 3:                                          //选择退出
		printf("您已经退出系统!\n");              
	break;
	default:
		printf("error：请输入1-3的整数\n");        //错误提示
	}
}

七、总结与不足
虽然凯撒密码的原理很简单，但是我在编程的过程中还是遇到很多麻烦，我在解决这些麻烦的过程中学到了很多有用的东西.
遇到的困难都是一些很简单的C语言常识，比如输入明文密文一开始用的是数组加for循环，但只能是一个一个的输入，查了一些资料后改用scanf（"%s",a）,这样可以输入一个字符串，但不能包含空格，遇到空格后会终止输入，在请教了同学之后又改用了gets()，这样就可以输入一个任意的字符串了，这个问题就这样解决了。比较麻烦的困难是加密的算法公式a[i]='a'+(a[i]-'a'-(k%26)+26)%26和解密的算法公式a[i]='a'+(a[i]-'a'-(k%26)+26)%26，网上其实有很多关于凯撒密码算法的公式，但我测试之后都不是很完美，大部分都是有限制条件的，而且有的会发生超界，经过仔细思考，修改之后得到了现在的这个公式，这样密钥就可以是任意的整数。
八、参考文献
[1]谭浩强 C程序设计（第三版） 清华大学出版社 2007







